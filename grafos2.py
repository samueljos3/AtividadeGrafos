# -*- coding: utf-8 -*-
"""grafos2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s0VweiTQXsj06wtacLd-OL-PsCyAHyKZ
"""

import queue

class Graph:
    def __init__(self, n):
        # Inicializa o grafo com um número fixo de vértices (n)
        self.num_vertices = n
        self.matrix = [[0 for i in range(n)] for i in range(n)]
        self.list = [[] for i in range(n)]

    def print(self):
        # Imprime a matriz de adjacência e a lista de adjacência do grafo
        print("Matriz_adj:\n", self.matrix)
        print("Lista_adj:\n", self.list)
        print("\n")

    def bfs(self, inicio):
        # Realiza a busca em largura no grafo a partir de um vértice de início
        fila = queue.Queue()
        dist = [-1 for i in range(self.num_vertices)]
        ant = [-1 for i in range(self.num_vertices)]
        isVisited = [False for i in range(self.num_vertices)]

        fila.put(inicio)
        isVisited[inicio] = True
        dist[inicio] = 0

        while not fila.empty():
            p = fila.get()
            print("Vertice: " + str(p))

            for v in self.list[p]:
                if not isVisited[v]:
                    dist[v] = dist[p] + 1
                    ant[v] = p
                    fila.put(v)
                    isVisited[v] = True

        return dist, ant

    def path_bfs(self, s, t, ant):
        # Encontra o caminho da busca em largura (BFS) entre dois vértices s e t
        path = []

        if ant[t] == -1:
            return f"Não há caminho entre {s} e {t}"

        while t != s:
            path.append(t)
            t = ant[t]
        path.append(s)
        path.reverse()

        return " -> ".join(map(str, path))

    def dfs(self, inicio):
        # Realiza a busca em profundidade (DFS) no grafo a partir de um vértice de início
        isVisited = [False for i in range(self.num_vertices)]
        resultado = []
        pilha = []

        pilha.append(inicio)
        isVisited[inicio] = True

        while pilha:
            vertice = pilha.pop()
            resultado.append(vertice)

            for vizinho in self.list[vertice]:
                if not isVisited[vizinho]:
                    pilha.append(vizinho)
                    isVisited[vizinho] = True

        return resultado